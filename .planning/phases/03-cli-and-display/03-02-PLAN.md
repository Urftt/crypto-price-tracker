---
phase: 03-cli-and-display
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/crypto_price_tracker/cli.py
  - tests/test_cli.py
autonomous: true
requirements:
  - CLI-01
  - CLI-02
  - CLI-03

must_haves:
  truths:
    - "`crypto prices` prints a formatted table of the top 20 coins with price, 24h change %, and volume, then exits"
    - "`crypto watch` refreshes the price table every 30 seconds by default; `--interval N` overrides the refresh period"
    - "`crypto info BTC` shows a detailed single-coin view for the given symbol"
    - "`crypto --help` lists all three subcommands with descriptions"
  artifacts:
    - path: "src/crypto_price_tracker/cli.py"
      provides: "CLI entry point with prices, watch, and info subcommands"
      exports: ["main"]
      min_lines: 60
    - path: "tests/test_cli.py"
      provides: "CLI integration tests verifying subcommand behavior"
      min_lines: 40
  key_links:
    - from: "src/crypto_price_tracker/cli.py"
      to: "src/crypto_price_tracker/api.py"
      via: "imports get_top_coins and BitvavoClient for data fetching"
      pattern: "from.*api.*import"
    - from: "src/crypto_price_tracker/cli.py"
      to: "src/crypto_price_tracker/display.py"
      via: "imports render_price_table and render_coin_detail for output"
      pattern: "from.*display.*import"
    - from: "src/crypto_price_tracker/cli.py"
      to: "argparse"
      via: "subparsers for prices, watch, info commands"
      pattern: "add_parser.*prices|add_parser.*watch|add_parser.*info"
---

<objective>
Implement the three CLI subcommands (`prices`, `watch`, `info`) that wire the Bitvavo API client to the terminal display module.

Purpose: This is the final wiring that makes the CLI tool usable. After this plan, users can run `crypto prices`, `crypto watch`, and `crypto info BTC` to see live cryptocurrency data in their terminal. This completes the entire v1.0 feature set.

Output: Updated `cli.py` with all three subcommands implemented, plus integration tests verifying command behavior.
</objective>

<execution_context>
@/home/james-turing/.claude/get-shit-done/workflows/execute-plan.md
@/home/james-turing/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-cli-and-display/03-01-SUMMARY.md
</context>

<interfaces>
<!-- From Phase 1 — existing CLI skeleton -->
From src/crypto_price_tracker/cli.py:
```python
import argparse

def main():
    parser = argparse.ArgumentParser(prog="crypto", description="...")
    subparsers = parser.add_subparsers(dest="command")
    args = parser.parse_args()
    if not args.command:
        parser.print_help()
```

<!-- From Phase 2 — API client -->
From src/crypto_price_tracker/api.py:
```python
BASE_URL = "https://api.bitvavo.com/v2"

class BitvavoClient:
    def __init__(self, top_n: int = 20): ...
    def get_top_coins(self) -> list[CoinData]: ...
    def __enter__(self): ...
    def __exit__(self, *args): ...

def get_top_coins(top_n: int = 20) -> list[CoinData]:
    """Convenience function — creates client, fetches, returns."""
```

<!-- From Plan 03-01 — display module -->
From src/crypto_price_tracker/display.py:
```python
def render_price_table(coins: list[CoinData], console: Console | None = None) -> None:
    """Render a table of coins to the terminal."""

def render_coin_detail(coin: CoinData, console: Console | None = None) -> None:
    """Render a single-coin detail view."""
```
</interfaces>

<tasks>

<task type="auto">
  <name>Task 1: Implement prices, watch, and info subcommands in cli.py</name>
  <files>src/crypto_price_tracker/cli.py</files>
  <action>
Rewrite `src/crypto_price_tracker/cli.py` to implement all three subcommands. Keep using `argparse` from stdlib (no click, no typer).

**Imports:**
```python
import argparse
import sys
import time

from crypto_price_tracker.api import get_top_coins
from crypto_price_tracker.display import render_price_table, render_coin_detail
```

**Subcommand registration in `main()`:**

After creating the `ArgumentParser` and `subparsers`, register three subcommands:

1. **prices subcommand:**
   ```python
   prices_parser = subparsers.add_parser("prices", help="Display top cryptocurrency prices")
   prices_parser.add_argument("-n", "--top", type=int, default=20, help="Number of top coins to display (default: 20)")
   ```

2. **watch subcommand:**
   ```python
   watch_parser = subparsers.add_parser("watch", help="Auto-refresh cryptocurrency prices")
   watch_parser.add_argument("-n", "--top", type=int, default=20, help="Number of top coins to display (default: 20)")
   watch_parser.add_argument("-i", "--interval", type=int, default=30, help="Refresh interval in seconds (default: 30)")
   ```

3. **info subcommand:**
   ```python
   info_parser = subparsers.add_parser("info", help="Show detailed info for a single coin")
   info_parser.add_argument("symbol", type=str, help="Coin symbol (e.g., BTC, ETH)")
   ```

**Command dispatch after `args = parser.parse_args()`:**

```python
if args.command == "prices":
    cmd_prices(args)
elif args.command == "watch":
    cmd_watch(args)
elif args.command == "info":
    cmd_info(args)
else:
    parser.print_help()
```

**Function `cmd_prices(args)`:**
- Call `coins = get_top_coins(top_n=args.top)`
- Call `render_price_table(coins)`
- Clean exit (just return)

**Function `cmd_watch(args)`:**
- Print a brief message: `f"Refreshing every {args.interval}s (Ctrl+C to stop)"`
- Enter an infinite loop:
  - Clear the terminal: `print("\033[2J\033[H", end="")` (ANSI clear screen + cursor home)
  - Call `coins = get_top_coins(top_n=args.top)`
  - Call `render_price_table(coins)`
  - Print a footer: `f"\nRefreshing every {args.interval}s — Ctrl+C to stop"`
  - `time.sleep(args.interval)`
- Wrap the loop in a `try/except KeyboardInterrupt` to exit gracefully:
  ```python
  try:
      while True:
          print("\033[2J\033[H", end="")
          coins = get_top_coins(top_n=args.top)
          render_price_table(coins)
          print(f"\nRefreshing every {args.interval}s — Ctrl+C to stop")
          time.sleep(args.interval)
  except KeyboardInterrupt:
      print("\nStopped.")
  ```

**Function `cmd_info(args)`:**
- Normalize symbol to uppercase: `symbol = args.symbol.upper()`
- Fetch a larger set of coins to search through: `coins = get_top_coins(top_n=100)`
- Find matching coin: `match = next((c for c in coins if c.symbol == symbol), None)`
- If found: `render_coin_detail(match)`
- If not found: `print(f"Coin '{symbol}' not found in top 100 EUR pairs on Bitvavo.", file=sys.stderr)` and `sys.exit(1)`

**Error handling:**
- Wrap the API calls in `cmd_prices` and `cmd_info` with a `try/except` for `httpx.HTTPStatusError` and `httpx.ConnectError`:
  ```python
  except (httpx.HTTPStatusError, httpx.ConnectError) as e:
      print(f"Error fetching data: {e}", file=sys.stderr)
      sys.exit(1)
  ```
- Add `import httpx` at the top for the error types.
- In `cmd_watch`, put the error handling inside the loop so one failed refresh doesn't kill the watcher — instead print the error and retry on next interval.

**Do NOT:**
- Use click, typer, or any other CLI framework — stick with argparse
- Add caching, config files, or persistent state
- Add colors to the CLI help text itself (only the data display is colored)
  </action>
  <verify>
    <automated>cd /home/james-turing/repos/crypto-price-tracker-v2 && uv run crypto --help 2>&1 | grep -q "prices" && uv run crypto --help 2>&1 | grep -q "watch" && uv run crypto --help 2>&1 | grep -q "info" && echo "PASS" || echo "FAIL"</automated>
  </verify>
  <done>`crypto --help` lists all three subcommands (prices, watch, info). `crypto prices --help` shows -n/--top flag. `crypto watch --help` shows -i/--interval and -n/--top flags. `crypto info --help` shows the symbol positional argument. All command dispatch works correctly.</done>
</task>

<task type="auto">
  <name>Task 2: Add CLI integration tests</name>
  <files>tests/test_cli.py</files>
  <action>
Create `tests/test_cli.py`. Tests should mock the API layer (not make real HTTP calls) and verify CLI behavior by invoking `main()` with patched `sys.argv`.

**Imports:**
```python
import sys
from unittest.mock import patch, MagicMock
import pytest
from crypto_price_tracker.models import CoinData
from crypto_price_tracker.cli import main
```

**Helper fixture `mock_coins`:**
```python
@pytest.fixture
def mock_coins():
    return [
        CoinData(symbol="BTC", name="Bitcoin", price=56754.0, change_24h=1.67, volume=2186.73, volume_eur=120339407.0),
        CoinData(symbol="ETH", name="Ethereum", price=2345.50, change_24h=-3.21, volume=45000.0, volume_eur=95000000.0),
    ]
```

**Test 1: `test_prices_command_calls_api_and_renders`**
- Patch `crypto_price_tracker.cli.get_top_coins` to return `mock_coins`
- Patch `crypto_price_tracker.cli.render_price_table` as a MagicMock
- Set `sys.argv = ["crypto", "prices"]`
- Call `main()`
- Assert `get_top_coins` was called with `top_n=20`
- Assert `render_price_table` was called once with the mock coins

**Test 2: `test_prices_command_respects_top_n_flag`**
- Patch `get_top_coins` and `render_price_table`
- Set `sys.argv = ["crypto", "prices", "-n", "10"]`
- Call `main()`
- Assert `get_top_coins` was called with `top_n=10`

**Test 3: `test_info_command_renders_matching_coin`**
- Patch `get_top_coins` to return `mock_coins`
- Patch `render_coin_detail` as a MagicMock
- Set `sys.argv = ["crypto", "info", "BTC"]`
- Call `main()`
- Assert `render_coin_detail` was called with the BTC CoinData object

**Test 4: `test_info_command_case_insensitive`**
- Patch `get_top_coins` to return `mock_coins`
- Patch `render_coin_detail`
- Set `sys.argv = ["crypto", "info", "btc"]` (lowercase)
- Call `main()`
- Assert `render_coin_detail` was called (symbol normalized to uppercase)

**Test 5: `test_info_command_not_found_exits_with_error`**
- Patch `get_top_coins` to return `mock_coins`
- Set `sys.argv = ["crypto", "info", "DOESNOTEXIST"]`
- Assert `main()` raises `SystemExit` with code 1 (use `pytest.raises(SystemExit)`)

**Test 6: `test_no_command_shows_help`**
- Patch `sys.argv = ["crypto"]`
- Capture stdout (use `capsys` fixture)
- Call `main()`
- Assert output contains "usage" or "crypto" (help text)

**Test 7: `test_watch_command_parses_interval`**
- Patch `get_top_coins` to return `mock_coins`
- Patch `render_price_table`
- Patch `time.sleep` to raise `KeyboardInterrupt` (so watch exits after one iteration)
- Set `sys.argv = ["crypto", "watch", "--interval", "10"]`
- Call `main()`
- Assert `get_top_coins` was called at least once
- Assert `render_price_table` was called at least once

Run tests:
```bash
uv run pytest tests/test_cli.py -v
```

All 7 tests must pass.
  </action>
  <verify>
    <automated>cd /home/james-turing/repos/crypto-price-tracker-v2 && uv run pytest tests/test_cli.py -v 2>&1 && echo "PASS" || echo "FAIL"</automated>
  </verify>
  <done>All 7 CLI integration tests pass. Tests verify: prices command calls API and renders, top-n flag works, info command finds and renders coin, symbol is case-insensitive, missing coin exits with error, no command shows help, watch command parses interval and handles KeyboardInterrupt.</done>
</task>

</tasks>

<verification>
Run these commands sequentially to verify the plan is complete:

1. `uv run crypto --help` — must list prices, watch, info subcommands
2. `uv run crypto prices --help` — must show -n/--top option
3. `uv run crypto watch --help` — must show -i/--interval and -n/--top options
4. `uv run crypto info --help` — must show symbol argument
5. `uv run pytest tests/test_cli.py -v` — all 7 tests pass
6. `uv run crypto prices -n 5` — prints a formatted table of 5 coins (live API call)
7. `uv run crypto info BTC` — prints Bitcoin detail view (live API call)
</verification>

<success_criteria>
1. `crypto prices` fetches top 20 coins and prints a formatted table, then exits
2. `crypto prices -n 10` fetches only 10 coins
3. `crypto watch` refreshes every 30 seconds by default with ANSI screen clearing
4. `crypto watch --interval 10` overrides the refresh period to 10 seconds
5. `crypto info BTC` shows a detailed single-coin view for Bitcoin
6. `crypto info btc` works (case-insensitive symbol matching)
7. `crypto info DOESNOTEXIST` prints an error and exits with code 1
8. `crypto --help` lists all three subcommands with descriptions
9. API errors are caught and printed to stderr (not unhandled tracebacks)
10. All 7 CLI integration tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/03-cli-and-display/03-02-SUMMARY.md`
</output>
