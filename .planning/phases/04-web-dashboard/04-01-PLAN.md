---
phase: 04-web-dashboard
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - pyproject.toml
  - src/crypto_price_tracker/web.py
  - src/crypto_price_tracker/cli.py
  - tests/test_web.py
autonomous: true
requirements:
  - WEB-01
  - WEB-04

must_haves:
  truths:
    - "A JSON endpoint at /api/prices returns the top N coins with symbol, name, price, change_24h, volume, and volume_eur fields"
    - "A JSON endpoint at /api/coin/{symbol} returns detailed data for a single coin"
    - "The web server starts via `crypto web` and listens on a configurable port (default 8000)"
    - "The /api/prices endpoint accepts an optional ?top=N query parameter (default 20)"
    - "API responses use the same CoinData model and Bitvavo client as the CLI"
  artifacts:
    - path: "src/crypto_price_tracker/web.py"
      provides: "FastAPI application with JSON API endpoints and static file serving"
      exports: ["app", "create_app"]
      min_lines: 50
    - path: "tests/test_web.py"
      provides: "Unit tests for the web API endpoints using FastAPI TestClient"
      min_lines: 40
  key_links:
    - from: "src/crypto_price_tracker/web.py"
      to: "src/crypto_price_tracker/api.py"
      via: "imports BitvavoClient and get_top_coins for data fetching"
      pattern: "from.*api.*import"
    - from: "src/crypto_price_tracker/web.py"
      to: "src/crypto_price_tracker/models.py"
      via: "imports CoinData for response serialization"
      pattern: "from.*models.*import.*CoinData"
    - from: "src/crypto_price_tracker/cli.py"
      to: "src/crypto_price_tracker/web.py"
      via: "imports create_app or run_server for the web subcommand"
      pattern: "from.*web.*import"
    - from: "tests/test_web.py"
      to: "src/crypto_price_tracker/web.py"
      via: "imports app for TestClient testing"
      pattern: "from.*web.*import"
---

<objective>
Create a FastAPI-based web server with JSON API endpoints that serve cryptocurrency price data, and add a `crypto web` CLI subcommand to start the server.

Purpose: This is the backend layer for the web dashboard. It exposes the same Bitvavo price data that the CLI displays, but as JSON endpoints that the browser-based frontend (Plan 04-02) will consume. The `crypto web` command makes starting the dashboard a single terminal command.

Output: A `web.py` module with FastAPI app, JSON API routes, and static file mount point. Updated `cli.py` with a `web` subcommand. Unit tests for all API endpoints.
</objective>

<execution_context>
@/home/james-turing/.claude/get-shit-done/workflows/execute-plan.md
@/home/james-turing/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
</context>

<interfaces>
<!-- From Phase 2 — the data model and API client this web module reuses -->
From src/crypto_price_tracker/models.py:
```python
@dataclass(slots=True)
class CoinData:
    symbol: str        # e.g., "BTC"
    name: str          # e.g., "Bitcoin"
    price: float       # Current price in EUR
    change_24h: float  # 24h change as percentage (e.g., 5.23 or -2.1)
    volume: float      # 24h trading volume in base asset
    volume_eur: float  # 24h trading volume in EUR
```

From src/crypto_price_tracker/api.py:
```python
BASE_URL = "https://api.bitvavo.com/v2"

class BitvavoClient:
    def __init__(self, top_n: int = 20): ...
    def get_top_coins(self) -> list[CoinData]: ...
    def __enter__(self): ...
    def __exit__(self, *args): ...

def get_top_coins(top_n: int = 20) -> list[CoinData]:
    """Convenience function — creates client, fetches, returns."""
```

From src/crypto_price_tracker/cli.py:
```python
def main() -> None:
    parser = argparse.ArgumentParser(prog="crypto", ...)
    subparsers = parser.add_subparsers(dest="command")
    # prices, watch, info subcommands already registered
    # Dispatch: if args.command == "prices": cmd_prices(args) ...
```
</interfaces>

<tasks>

<task type="auto">
  <name>Task 1: Add FastAPI/uvicorn dependencies and create web module with JSON API endpoints</name>
  <files>pyproject.toml, src/crypto_price_tracker/web.py</files>
  <action>
**Step 1: Add dependencies to pyproject.toml**

Add `fastapi>=0.115` and `uvicorn[standard]>=0.34` to the `dependencies` list:
```toml
dependencies = ["httpx>=0.27", "rich>=13.0", "fastapi>=0.115", "uvicorn[standard]>=0.34"]
```

Run `/home/james-turing/.local/bin/uv sync` to install them.

**Step 2: Create `src/crypto_price_tracker/web.py`**

This module creates a FastAPI application that serves JSON API endpoints for crypto price data. It also mounts a static files directory for the HTML frontend (created in Plan 04-02).

**Imports:**
```python
from __future__ import annotations

import dataclasses
from pathlib import Path

from fastapi import FastAPI, Query
from fastapi.responses import FileResponse
from fastapi.staticfiles import StaticFiles

from crypto_price_tracker.api import get_top_coins
from crypto_price_tracker.models import CoinData
```

**Static directory setup:**
```python
STATIC_DIR = Path(__file__).parent / "static"
```

**Factory function `create_app() -> FastAPI`:**

Create and return a configured FastAPI instance:

```python
def create_app() -> FastAPI:
    app = FastAPI(title="Crypto Price Tracker", version="0.1.0")
```

**Route 1: `GET /api/prices`**

Returns the top N coins as a JSON array. Accepts an optional `top` query parameter (default 20, min 1, max 100).

```python
@app.get("/api/prices")
def api_prices(top: int = Query(default=20, ge=1, le=100)):
    coins = get_top_coins(top_n=top)
    return [dataclasses.asdict(c) for c in coins]
```

Use `dataclasses.asdict()` to convert CoinData to dict for JSON serialization. This avoids needing Pydantic models since CoinData is a stdlib dataclass.

**Route 2: `GET /api/coin/{symbol}`**

Returns detailed data for a single coin. Searches the top 100 coins (same as CLI `info` command). Returns 404 if not found.

```python
from fastapi import HTTPException

@app.get("/api/coin/{symbol}")
def api_coin(symbol: str):
    symbol = symbol.upper()
    coins = get_top_coins(top_n=100)
    match = next((c for c in coins if c.symbol == symbol), None)
    if match is None:
        raise HTTPException(status_code=404, detail=f"Coin '{symbol}' not found in top 100 EUR pairs")
    return dataclasses.asdict(match)
```

**Route 3: `GET /` (index)**

Serve the static index.html file. If the file does not exist yet (Plan 04-02 creates it), return a JSON message indicating the frontend is not yet built.

```python
@app.get("/")
def index():
    index_path = STATIC_DIR / "index.html"
    if index_path.exists():
        return FileResponse(index_path)
    return {"message": "Crypto Price Tracker API", "docs": "/docs"}
```

**Static files mount:**

Mount the static directory for CSS/JS assets. Only mount if the directory exists (it will be created by Plan 04-02):

```python
if STATIC_DIR.exists():
    app.mount("/static", StaticFiles(directory=str(STATIC_DIR)), name="static")

return app
```

**Module-level app instance:**
```python
app = create_app()
```

This allows `uvicorn crypto_price_tracker.web:app` to work directly.

**Run helper:**
```python
def run_server(host: str = "0.0.0.0", port: int = 8000) -> None:
    """Start the uvicorn server."""
    import uvicorn
    uvicorn.run(app, host=host, port=port)
```

**Important notes:**
- Use `dataclasses.asdict()` for serialization — do NOT create duplicate Pydantic models for CoinData.
- The get_top_coins() function uses httpx (synchronous). FastAPI handles this fine since uvicorn runs it in a threadpool for sync endpoints.
- Keep the static directory path relative to the web.py module so it works regardless of working directory.
- Do NOT add CORS middleware yet — the frontend is served from the same origin.
  </action>
  <verify>
    <automated>cd /home/james-turing/repos/crypto-price-tracker-v2 && /home/james-turing/.local/bin/uv sync 2>&1 | tail -3 && /home/james-turing/.local/bin/uv run python -c "from crypto_price_tracker.web import app, create_app, run_server; print('imports OK')" && echo "PASS" || echo "FAIL"</automated>
  </verify>
  <done>fastapi and uvicorn are in pyproject.toml dependencies and installed. web.py exports app, create_app, and run_server. The app has /api/prices and /api/coin/{symbol} routes. All imports resolve without error.</done>
</task>

<task type="auto">
  <name>Task 2: Add `crypto web` subcommand and write API tests</name>
  <files>src/crypto_price_tracker/cli.py, tests/test_web.py</files>
  <action>
**Step 1: Add `web` subcommand to cli.py**

In `src/crypto_price_tracker/cli.py`, add a new subcommand registration after the existing `info` subcommand block:

```python
# web subcommand
web_parser = subparsers.add_parser("web", help="Start the web dashboard server")
web_parser.add_argument(
    "-p", "--port",
    type=int,
    default=8000,
    help="Port to listen on (default: 8000)",
)
web_parser.add_argument(
    "--host",
    type=str,
    default="0.0.0.0",
    help="Host to bind to (default: 0.0.0.0)",
)
```

Add a new `cmd_web` function:

```python
def cmd_web(args: argparse.Namespace) -> None:
    """Start the web dashboard server."""
    from crypto_price_tracker.web import run_server
    print(f"Starting web dashboard at http://localhost:{args.port}")
    run_server(host=args.host, port=args.port)
```

Use a lazy import (`from crypto_price_tracker.web import run_server`) inside the function body so that FastAPI/uvicorn are only imported when the `web` subcommand is actually used. This keeps `crypto prices` and other CLI commands fast.

Add the dispatch case in the `main()` function:

```python
elif args.command == "web":
    cmd_web(args)
```

Insert this BEFORE the `else: parser.print_help()` block.

**Step 2: Create `tests/test_web.py`**

Use FastAPI's `TestClient` (from `starlette.testclient`) to test the API endpoints. Mock the `get_top_coins` function to avoid real HTTP calls.

**Imports:**
```python
from unittest.mock import patch
import pytest
from starlette.testclient import TestClient
from crypto_price_tracker.models import CoinData
from crypto_price_tracker.web import create_app
```

**Test app fixture:**
```python
@pytest.fixture
def client():
    app = create_app()
    return TestClient(app)
```

**Mock coins fixture:**
```python
@pytest.fixture
def mock_coins():
    return [
        CoinData(symbol="BTC", name="Bitcoin", price=56754.0, change_24h=1.67, volume=2186.73, volume_eur=120339407.0),
        CoinData(symbol="ETH", name="Ethereum", price=2345.50, change_24h=-3.21, volume=45000.0, volume_eur=95000000.0),
        CoinData(symbol="XRP", name="Ripple", price=0.52, change_24h=0.0, volume=1000000.0, volume_eur=520000.0),
    ]
```

**Test 1: `test_api_prices_returns_json_list`**
- Patch `crypto_price_tracker.web.get_top_coins` to return `mock_coins`
- GET `/api/prices`
- Assert status 200
- Assert response JSON is a list of 3 dicts
- Assert first item has keys: symbol, name, price, change_24h, volume, volume_eur
- Assert first item's symbol is "BTC"

**Test 2: `test_api_prices_respects_top_param`**
- Patch `get_top_coins` to return `mock_coins`
- GET `/api/prices?top=2`
- Assert `get_top_coins` was called with `top_n=2`

**Test 3: `test_api_coin_returns_single_coin`**
- Patch `get_top_coins` to return `mock_coins`
- GET `/api/coin/BTC`
- Assert status 200
- Assert response JSON has `symbol` == "BTC" and `name` == "Bitcoin"

**Test 4: `test_api_coin_case_insensitive`**
- Patch `get_top_coins` to return `mock_coins`
- GET `/api/coin/btc` (lowercase)
- Assert status 200
- Assert response JSON has `symbol` == "BTC"

**Test 5: `test_api_coin_not_found_returns_404`**
- Patch `get_top_coins` to return `mock_coins`
- GET `/api/coin/DOESNOTEXIST`
- Assert status 404

**Test 6: `test_index_returns_response`**
- GET `/`
- Assert status 200 (returns either index.html or the JSON fallback message)

Run tests:
```bash
/home/james-turing/.local/bin/uv run pytest tests/test_web.py -v
```

All 6 tests must pass.
  </action>
  <verify>
    <automated>cd /home/james-turing/repos/crypto-price-tracker-v2 && /home/james-turing/.local/bin/uv run crypto --help 2>&1 | grep -q "web" && /home/james-turing/.local/bin/uv run pytest tests/test_web.py -v 2>&1 && echo "PASS" || echo "FAIL"</automated>
  </verify>
  <done>`crypto --help` lists the web subcommand. `crypto web --help` shows --port and --host options. All 6 web API tests pass. Tests verify: prices endpoint returns JSON list, top param works, single coin lookup works, case-insensitive symbol lookup, 404 for unknown coins, index route responds.</done>
</task>

</tasks>

<verification>
Run these commands sequentially to verify the plan is complete:

1. `/home/james-turing/.local/bin/uv sync` — must install fastapi and uvicorn without error
2. `/home/james-turing/.local/bin/uv run python -c "from crypto_price_tracker.web import app, create_app, run_server; print('OK')"` — imports resolve
3. `/home/james-turing/.local/bin/uv run crypto --help` — must list web subcommand alongside prices, watch, info
4. `/home/james-turing/.local/bin/uv run crypto web --help` — must show --port and --host options
5. `/home/james-turing/.local/bin/uv run pytest tests/test_web.py -v` — all 6 tests pass
6. `/home/james-turing/.local/bin/uv run pytest tests/ -v` — all existing tests still pass (no regressions)
</verification>

<success_criteria>
1. fastapi and uvicorn are listed as dependencies in pyproject.toml and installed via uv sync
2. web.py exports create_app(), app, and run_server()
3. GET /api/prices returns JSON array of coin data with all 6 fields
4. GET /api/prices?top=5 returns only 5 coins
5. GET /api/coin/BTC returns detailed JSON for Bitcoin
6. GET /api/coin/INVALID returns 404
7. `crypto web` starts the server on port 8000 by default
8. `crypto web --port 9000` overrides the port
9. All 6 web API tests pass
10. All existing CLI and display tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/04-web-dashboard/04-01-SUMMARY.md`
</output>
